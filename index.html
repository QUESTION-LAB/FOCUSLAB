<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>FOCUSLAB</title>

<style>
* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
  font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Display', sans-serif;
}

body {
  background: #0d1117;
  color: #e6edf3;
  min-height: 100vh;
  padding: clamp(16px, 4vw, 50px) clamp(14px, 5vw, 70px);
  padding-left: max(clamp(14px, 5vw, 70px), env(safe-area-inset-left));
  padding-right: max(clamp(14px, 5vw, 70px), env(safe-area-inset-right));
  padding-top: max(clamp(16px, 4vw, 50px), env(safe-area-inset-top));
  padding-bottom: max(clamp(16px, 4vw, 50px), env(safe-area-inset-bottom));
  overflow-x: hidden;
}

.container {
  max-width: 1400px;
  margin: 0 auto;
  display: flex;
  flex-direction: column;
  gap: clamp(28px, 5vw, 70px);
}

/* ================= TOP ================= */

.top-dashboard {
  display: grid;
  grid-template-columns: repeat(6, minmax(0, 1fr));
  gap: clamp(16px, 3.5vw, 28px);
  align-items: stretch;
}

.timer-card {
  grid-column: 1 / 7;
  text-align: center;
  padding: clamp(22px, 5vw, 50px) clamp(16px, 4vw, 30px);
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  border-radius: 24px;
  background: #11161d;
  border: 1px solid #1f2630;
  box-shadow: 0 0 0 1px #1f2630;
  min-width: 0;
}

.timer {
  font-size: clamp(56px, 10vw, 120px);
  font-weight: 600;
  letter-spacing: clamp(2px, 1.2vw, 10px);
  color: #f0f6fc;
}

.control-buttons {
  margin-top: 25px;
  display: flex;
  flex-wrap: wrap;
  gap: 10px;
  justify-content: center;
}

button {
  padding: 10px 20px;
  border-radius: 999px;
  border: 1px solid #2d333b;
  background: #161b22;
  color: #c9d1d9;
  cursor: pointer;
  font-size: 13px;
  margin: 0;
  transition: all .2s ease;
  min-height: 40px;
}

button:hover {
  background: #1f2630;
  border-color: #30363d;
}

.stat-card {
  background: #11161d;
  border-radius: 20px;
  padding: 30px;
  border: 1px solid #1f2630;
  display: flex;
  flex-direction: column;
  justify-content: center;
  height: 100%;
  transition: all .2s ease;
  min-height: 260px;
  min-width: 0;
}

.stat-card:hover {
  border-color: #2d333b;
}

.stat-card h3 {
  font-size: 12px;
  color: #8b949e;
  margin-bottom: 14px;
  letter-spacing: 1px;
}

.score {
  font-size: 80px;
  font-weight: 700;
  color: #f0f6fc;
}

.score.small {
  font-size: 64px;
}

input {
  width: 100%;
  padding: 12px;
  border-radius: 12px;
  border: 1px solid #2d333b;
  background: #0d1117;
  color: #e6edf3;
  margin-bottom: 12px;
  outline: none;
  transition: all .2s ease;
}

input:focus {
  border-color: #3b82f6;
}

.graph-bar {
  height: 8px;
  background: #1f2630;
  border-radius: 8px;
  overflow: hidden;
}

.graph-fill {
  height: 100%;
  width: 0%;
  background: #3b82f6;
  transition: width .4s ease;
}

#warning {
  margin-top: 15px;
  font-size: 14px;
  color: #ff7b72;
}

/* ================= LOWER ================= */

.lower-dashboard {
  display: grid;
  grid-template-columns: repeat(2, 1fr);
  gap: clamp(16px, 4vw, 35px);
}

canvas {
  display: block;
  width: 100%;
  height: auto;
  max-width: 100%;
}

.card {
  background: #11161d;
  border-radius: 20px;
  padding: 30px;
  border: 1px solid #1f2630;
  transition: all .2s ease;
  min-width: 0;
}

  .card:hover {
    border-color: #2d333b;
  }

  .stamp {
    aspect-ratio: 1/1;
    border-radius: 14px;
    background: #161b22;
    border: 1px solid #2d333b;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 18px;
    opacity: 0.3;
    transition: all .3s ease;
    transform: scale(0.92);
  }

  .stamp.unlocked {
    opacity: 1;
    background: #0a84ff;
    border-color: #3b82f6;
  }

  /* =============== UNLOCK POP ANIMATION + RARITY SYSTEM =============== */
  @keyframes stampPop {
    0% { transform: scale(0.6); opacity: 0; }
    60% { transform: scale(1.2); }
    100% { transform: scale(1); opacity: 1; }
  }

  .stamp.pop {
    animation: stampPop 0.4s ease forwards;
  }

  .stamp.common.unlocked {
    background: #1f6feb;
  }

  .stamp.rare.unlocked {
    background: linear-gradient(135deg, #0a84ff, #34c759);
  }

  .stamp.legendary.unlocked {
    background: linear-gradient(135deg, #ff9f0a, #ff375f);
    box-shadow: 0 0 15px rgba(255,159,10,0.6);
  }

/* ================= TOOLTIP ================= */
.stamp-wrapper {
  position: relative;
}

.stamp-tooltip {
  position: absolute;
  bottom: 110%;
  left: 50%;
  transform: translateX(-50%);
  background: #0d1117;
  color: #e6edf3;
  padding: 6px 10px;
  font-size: 11px;
  border-radius: 8px;
  border: 1px solid #2d333b;
  white-space: nowrap;
  opacity: 0;
  pointer-events: none;
  transition: opacity .2s ease;
  z-index: 10;
}

.stamp-wrapper:hover .stamp-tooltip {
  opacity: 1;
}

/* ================= RANK THEMES ================= */
body.rank-bronze { }

body.rank-silver {
  background: linear-gradient(180deg, #0d1117, #111827);
}

body.rank-gold {
  background: linear-gradient(180deg, #0d1117, #1a1f2e);
}

body.rank-platinum {
  background: linear-gradient(180deg, #0d1117, #0f2027);
}

body.rank-diamond {
  background: radial-gradient(circle at top, #1a1f2e, #0d1117);
}

@keyframes rankPop {
  0% { transform: scale(1); }
  50% { transform: scale(1.25); }
  100% { transform: scale(1); }
}

.rank-up {
  animation: rankPop .6s ease;
}

@keyframes rpFloat {
  0% { opacity:0; transform:translateY(10px); }
  30% { opacity:1; transform:translateY(0); }
  100% { opacity:0; transform:translateY(-20px); }
}

.rp-float {
  position:absolute;
  top:-10px;
  right:0;
  font-size:14px;
  color:#34c759;
  font-weight:600;
  animation: rpFloat 1s ease forwards;
  pointer-events:none;
}

/* Timer color by rank */
body.rank-bronze .timer { color:#f0f6fc; }
body.rank-silver .timer { color:#b8d4ff; }
body.rank-gold .timer { color:#ffd166; }
body.rank-platinum .timer { color:#7ee0ff; }

body.rank-diamond .timer {
  color:#ff9f0a;
  font-family:"SF Mono", monospace;
}

body.rank-diamond .timer-card {
  box-shadow:0 0 40px rgba(255,159,10,0.3);
}

/* Diamond Glow Effect */
body.rank-diamond .container {
  box-shadow: 0 0 40px rgba(255, 159, 10, 0.15);
}

@keyframes diamondPulse {
  0% { box-shadow: 0 0 0px rgba(255,159,10,0.4); }
  50% { box-shadow: 0 0 25px rgba(255,159,10,0.7); }
  100% { box-shadow: 0 0 0px rgba(255,159,10,0.4); }
}

body.rank-diamond .timer-card {
  animation: diamondPulse 2s infinite;
}

.card h3 {
  font-size: 13px;
  color: #8b949e;
  margin-bottom: 18px;
}

#heatmap div {
  width: 100%;
  aspect-ratio: 1/1;
  border-radius: 6px;
  background: #161b22;
  transition: all .2s ease;
}

#heatmap div:hover {
  background: #1f2630;
}

.control-hub {
  justify-content: space-between;
}

  .session-metrics {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    gap: 20px;
    margin-top: 20px;
    padding-top: 15px;
    border-top: 1px solid #1f2630;
  }

  .session-metrics > div {
    display: flex;
    flex-direction: column;
    gap: 6px;
  }

  .metric-label {
    font-size: 11px;
    color: #6e7681;
    letter-spacing: 1.5px;
    text-transform: uppercase;
  }

.session-metrics span:last-child {
  font-size: 18px;
  color: #e6edf3;
}

.strategy-section {
  margin-top: 20px;
  padding-top: 15px;
  border-top: 1px solid #1f2630;
}

@media(max-width:1100px) {
  .top-dashboard {
    grid-template-columns: 1fr;
  }
  .lower-dashboard {
    grid-template-columns: 1fr;
  }
  .stat-card {
    min-height: unset;
    padding: 22px;
  }
  .card {
    padding: 22px;
  }
}

@media(max-width:768px) {
  button {
    padding: 12px 16px;
    min-height: 44px;
    font-size: 15px;
  }

  input,
  select {
    font-size: 16px;
  }

  .score {
    font-size: 64px;
  }

  .score.small {
    font-size: 52px;
  }

  .session-metrics {
    grid-template-columns: 1fr;
    gap: 14px;
  }

  #rankContainer > div:nth-child(1) {
    letter-spacing: 1.5px;
  }
}

@media(max-width:480px) {
  .timer-card {
    border-radius: 18px;
  }

  #rankContainer > div:nth-child(4) {
    width: min(240px, 80vw) !important;
  }

  .stat-card,
  .card {
    border-radius: 18px;
    padding: 18px;
  }

  #stampGrid {
    grid-template-columns: repeat(3, 1fr) !important;
  }

  #heatmap {
    gap: 3px !important;
  }
}
</style>
</head>

<body>

<div class="container">

  <!-- ================= TOP ZONE ================= -->
  <div class="top-dashboard">

  <div class="timer-card">
    <div class="timer" id="timer">00:00:00</div>
    <div id="rankContainer" style="margin-top:25px; position:relative;">
      <div style="font-size:12px; letter-spacing:2px; color:#8b949e; margin-bottom:6px;">PERFORMANCE RANK</div>
      <div id="rankDisplay" style="font-size:28px; font-weight:600;">Bronze ğŸ¥‰</div>
      <div id="rankProgress" style="margin-top:6px; font-size:11px; opacity:0.7;"></div>
      <div style="margin-top:12px; width:240px; height:6px; background:#1f2630; border-radius:6px; overflow:hidden;">
  <div id="rpBar" style="height:100%; width:0%; background:#3b82f6; transition:width .4s ease;"></div>
</div>
<div id="rpText" style="margin-top:6px; font-size:11px; opacity:0.7;">0 RP</div>
    </div>
    <div id="warning"></div>
    <div class="control-buttons">
      <button onclick="startTimer()">Start</button>
      <button onclick="stopTimer()">Stop</button>
      <button onclick="resetTimer()">Reset</button>
      <button onclick="startExamMode()">Exam</button>
      <button onclick="goToAnalytics()">AI ë¶„ì„</button>
    </div>
  </div>

  <div class="stat-card" style="grid-column: span 1;">
    <h3>BODY INPUT</h3>
    <input type="number" id="sleepInput" placeholder="ìˆ˜ë©´ ì‹œê°„ (ë¶„)" />
    <input type="number" id="runTimeInput" placeholder="ìš´ë™ ì‹œê°„" />
    <input type="number" id="runDistanceInput" placeholder="ê±°ë¦¬ (km)" />
    <input type="number" id="caffeineInput" placeholder="ì¹´í˜ì¸ íšŸìˆ˜" />
    <input type="number" id="waterInput" placeholder="ë¬¼ ì„­ì·¨ëŸ‰ (ml)" />
    <select id="subjectInput" style="width:100%; padding:12px; border-radius:12px; border:1px solid #2d333b; background:#0d1117; color:#e6edf3; margin-bottom:12px;">
      <option value="êµ­ì–´">êµ­ì–´</option>
      <option value="ì˜ì–´">ì˜ì–´</option>
      <option value="ìˆ˜í•™">ìˆ˜í•™</option>
      <option value="ê¸°íƒ€">ê¸°íƒ€</option>
    </select>
  </div>

  <div class="stat-card" style="grid-column: span 1;">
    <h3>FOCUS SCORE</h3>
    <div class="score" id="score">0</div>
  </div>

  <div class="stat-card" style="grid-column: span 1;">
    <h3>AI PREDICTED</h3>
    <div class="score small" id="predictedScore">0</div>
  </div>

  <!-- ğŸ”¥ CONTROL HUB -->
  <div class="stat-card control-hub" style="grid-column: span 3;">

    <div>
      <h3>STABILITY</h3>
      <div class="graph-bar">
        <div class="graph-fill" id="stabilityBar"></div>
      </div>

      <h3 style="margin-top:20px;">PREDICTION GAUGE</h3>
      <div class="graph-bar">
        <div class="graph-fill" id="predictionBar"></div>
      </div>
    </div>

    <div class="session-metrics">
      <div>
        <span class="metric-label">DISTRACTIONS</span>
        <span id="distractionCountUI">0</span>
      </div>
      <div>
        <span class="metric-label">SESSION (MIN)</span>
        <span id="sessionMinutesUI">0</span>
      </div>
      <div>
        <span class="metric-label">MOMENTUM</span>
        <span id="momentumUI">0%</span>
      </div>
    </div>

    <div class="strategy-section">
      <h3 style="margin-top:25px;">ì˜¤ëŠ˜ì˜ ì§‘ì¤‘ ì „ëµ</h3>
      <div id="dailyStrategy" style="font-size:13px; line-height:1.6; color:#c9d1d9;">
        ë°ì´í„° ë¶„ì„ ì¤‘...
      </div>
    </div>

  </div>

</div>

  <!-- ================= LOWER DASHBOARD ================= -->

  <div class="lower-dashboard">

    <div class="card">
      <h3>ì§‘ì¤‘ íƒ€ì„ë¼ì¸</h3>
      <canvas id="focusChart" width="400" height="150"></canvas>
    </div>

    <div class="card">
      <h3>ì§‘ì¤‘ ì˜í–¥ ìš”ì¸ ë¶„ì„</h3>
      <canvas id="correlationChart" width="400" height="150"></canvas>
      <p id="correlationValues" style="margin-top:10px; font-size:12px; opacity:0.8;"></p>
    </div>

    <div class="card">
      <h3>ì§‘ì¤‘ ë¦¬ë“¬ ë¶„ì„</h3>
      <p id="focusRhythm">ë°ì´í„° ë¶„ì„ ì¤‘...</p>
    </div>

    <div class="card">
      <h3>í¬ë¡œë…¸íƒ€ì… ë¶„ì„</h3>
      <p id="chronotypeResult">ë¶„ì„ ì¤‘...</p>
    </div>
    
    <div class="card">
      <h3>ì£¼ê°„ ë¦¬í¬íŠ¸</h3>
      <p id="weeklyReport">ë°ì´í„° ìˆ˜ì§‘ ì¤‘...</p>
      <h3 style="margin-top:20px;">ëˆ„ì  í†µê³„</h3>
      <p id="totalStats"></p>
    </div>

    <div class="card">
  <h3>ì¼ë³„ í™œë™ íƒ€ì„ë¼ì¸</h3>
  <canvas id="activityTimeline" width="400" height="100"></canvas>
</div>

    <div class="card">
      <h3>ì›”ë³„ ì§‘ì¤‘ íˆíŠ¸ë§µ</h3>
      <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:10px;">
        <button onclick="changeMonth(-1)">â—€</button>
        <div id="heatmapMonth"></div>
        <button onclick="changeMonth(1)">â–¶</button>
      </div>
      <div id="heatmap" style="display:grid; grid-template-columns: repeat(7, 1fr); gap:4px;"></div>
      <div style="margin-top:10px; font-size:12px; opacity:0.8;">
        ğŸ”¥ Current Streak: <span id="currentStreak">0</span> days<br>
        ğŸ† Best Streak: <span id="bestStreak">0</span> days
      </div>
      <div id="streakBadge" style="margin-top:10px; font-size:12px;"></div>
    </div>

    <div class="card">
      <h3>ì—…ì  ìŠ¤íƒ¬í”„</h3>
      <div id="stampGrid" style="display:grid; grid-template-columns: repeat(4, 1fr); gap:15px;"></div>
    </div>




  </div>

</div>

<script>
function goToAnalytics() {
  window.location.href = "analytics.html";
}
let timerInterval;
let seconds = 0;
let distractionCount = 0;
let active = false;
let focusData = [];
let currentRunTime = 0;
let studyStartTime = null;
let studyEndTime = null;
let heatmapDate = new Date();

let adaptiveWeights = JSON.parse(localStorage.getItem("adaptiveWeights")) || {
  sleep:1,
  exercise:1,
  caffeine:1
};

// ================= REAL AI MODEL =================
let aiModel = JSON.parse(localStorage.getItem("aiModel")) || {
  wSleep: 0.05,
  wExercise: 0.03,
  wCaffeine: -0.04,
  wWater: 0.002,
  bias: 10
};

function predictScoreAI(sleepMin, runTime, caffeine, water) {
  return aiModel.bias
    + aiModel.wSleep * sleepMin
    + aiModel.wExercise * runTime
    + aiModel.wCaffeine * caffeine
    + aiModel.wWater * water;
}

function trainAIModel(actual, sleepMin, runTime, caffeine, water) {
  const prediction = predictScoreAI(sleepMin, runTime, caffeine, water);
  const error = actual - prediction;

  const lr = 0.0000005; // learning rate (ì‘ê²Œ!)

  aiModel.wSleep += lr * error * sleepMin;
  aiModel.wExercise += lr * error * runTime;
  aiModel.wCaffeine += lr * error * caffeine;
  aiModel.wWater += lr * error * water;
  aiModel.bias += lr * error;

  localStorage.setItem("aiModel", JSON.stringify(aiModel));
}

// ================= RANK POINT SYSTEM =================

// ================= SESSION PERSISTENCE =================
function saveLiveSessionState() {
  localStorage.setItem("liveSession", JSON.stringify({
    seconds,
    distractionCount,
    active,
    studyStartTime
  }));
}

function loadLiveSessionState() {
  const saved = JSON.parse(localStorage.getItem("liveSession"));
  if (!saved) return;

  seconds = saved.seconds || 0;
  distractionCount = saved.distractionCount || 0;
  active = saved.active || false;
  studyStartTime = saved.studyStartTime || null;

  const hrs = String(Math.floor(seconds / 3600)).padStart(2, '0');
  const mins = String(Math.floor((seconds % 3600) / 60)).padStart(2, '0');
  const secs = String(seconds % 60).padStart(2, '0');
  document.getElementById("timer").textContent = `${hrs}:${mins}:${secs}`;

  document.getElementById("distractionCountUI").textContent = distractionCount;
  document.getElementById("sessionMinutesUI").textContent = Math.floor(seconds / 60);

  if (active) {
    timerInterval = setInterval(updateTimer, 1000);
  }
}


window.addEventListener("beforeunload", saveLiveSessionState);

// ================= BODY INPUT PERSISTENCE =================
function saveBodyInputs() {
  const bodyData = {
    sleep: document.getElementById("sleepInput").value,
    runTime: document.getElementById("runTimeInput").value,
    runDistance: document.getElementById("runDistanceInput").value,
    caffeine: document.getElementById("caffeineInput").value,
    water: document.getElementById("waterInput").value,
    subject: document.getElementById("subjectInput").value
  };
  localStorage.setItem("bodyInputs", JSON.stringify(bodyData));
}

function loadBodyInputs() {
  const saved = JSON.parse(localStorage.getItem("bodyInputs"));
  if (!saved) return;

  document.getElementById("sleepInput").value = saved.sleep || "";
  document.getElementById("runTimeInput").value = saved.runTime || "";
  document.getElementById("runDistanceInput").value = saved.runDistance || "";
  document.getElementById("caffeineInput").value = saved.caffeine || "";
  document.getElementById("waterInput").value = saved.water || "";
  document.getElementById("subjectInput").value = saved.subject || "êµ­ì–´";
}

// auto-save on input change
["sleepInput","runTimeInput","runDistanceInput","caffeineInput","waterInput","subjectInput"]
  .forEach(id => {
    document.getElementById(id).addEventListener("input", saveBodyInputs);
  });


let rankPoints = Number(localStorage.getItem("rankPoints")) || 0;

// ================= DASHBOARD STATE PERSISTENCE =================
function saveDashboardState(){
  const state = {
    score: document.getElementById("score").textContent,
    predicted: document.getElementById("predictedScore").textContent,
    stabilityWidth: document.getElementById("stabilityBar").style.width,
    predictionWidth: document.getElementById("predictionBar").style.width
  };
  localStorage.setItem("dashboardState", JSON.stringify(state));
}

function loadDashboardState(){
  const saved = JSON.parse(localStorage.getItem("dashboardState"));
  if(!saved) return;

  document.getElementById("score").textContent = saved.score || 0;
  document.getElementById("predictedScore").textContent = saved.predicted || 0;
  document.getElementById("stabilityBar").style.width = saved.stabilityWidth || "0%";
  document.getElementById("predictionBar").style.width = saved.predictionWidth || "0%";
}


const subjectColors = {
  "êµ­ì–´": "#ff375f",
  "ì˜ì–´": "#0a84ff",
  "ìˆ˜í•™": "#34c759",
  "ê¸°íƒ€": "#8e8e93"
};

const exerciseColor = "#ff9f0a";

const ctx = document.getElementById("focusChart").getContext("2d");
const corrCtx = document.getElementById("correlationChart").getContext("2d");
// Pearson correlation calculation
function pearsonCorrelation(x, y) {
  const n = x.length;
  if (n === 0) return 0;

  const meanX = x.reduce((a,b)=>a+b,0) / n;
  const meanY = y.reduce((a,b)=>a+b,0) / n;

  let numerator = 0;
  let denomX = 0;
  let denomY = 0;

  for (let i = 0; i < n; i++) {
    const diffX = x[i] - meanX;
    const diffY = y[i] - meanY;

    numerator += diffX * diffY;
    denomX += diffX * diffX;
    denomY += diffY * diffY;
  }

  const denominator = Math.sqrt(denomX * denomY);
  if (denominator === 0) return 0;

  return numerator / denominator;
}


function updateTimer() {
  seconds++;

  const hrs = String(Math.floor(seconds / 3600)).padStart(2, '0');
  const mins = String(Math.floor((seconds % 3600) / 60)).padStart(2, '0');
  const secs = String(seconds % 60).padStart(2, '0');
  document.getElementById("timer").textContent = `${hrs}:${mins}:${secs}`;

  if (active) {
    let baseStability = Math.max(0, 100 - distractionCount * 5);

  // ì°½ì´ í¬ì»¤ìŠ¤ ì•„ë‹ ë•Œ ì¶”ê°€ ê°ì 
  let decay = document.hasFocus() ? 0 : 3;

  let stability = Math.max(0, baseStability - decay);
    document.getElementById("stabilityBar").style.width = stability + "%";

    focusData.push(stability);
    drawChart();

    if (stability < 60) {
      document.getElementById("warning").textContent = "âš  ì§‘ì¤‘ë ¥ ì €í•˜ ê°ì§€";
    } else {
      document.getElementById("warning").textContent = "";
    }
  }

  document.getElementById("distractionCountUI").textContent = distractionCount;
document.getElementById("sessionMinutesUI").textContent = Math.floor(seconds / 60);

if (focusData.length > 10) {
  let recent = focusData.slice(-5);
  let previous = focusData.slice(-10, -5);

  let avgRecent = recent.reduce((a,b)=>a+b,0)/recent.length;
  let avgPrev = previous.reduce((a,b)=>a+b,0)/previous.length;

  let momentum = Math.round(avgRecent - avgPrev);
  document.getElementById("momentumUI").textContent =
    momentum > 0 ? "+"+momentum+"%" : momentum+"%";
}
  saveDashboardState();
  saveLiveSessionState();
}

function startTimer() {
  if (!active) {
    studyStartTime = Date.now();
    active = true;
    timerInterval = setInterval(updateTimer, 1000);
  }
}

function stopTimer() {
  if (active) {
    studyEndTime = Date.now();
    active = false;
    clearInterval(timerInterval);
    calculateScore();
    localStorage.removeItem("liveSession");
  }
}

function resetTimer() {
  clearInterval(timerInterval);
  seconds = 0;
  distractionCount = 0;
  active = false;
  focusData = [];
  document.getElementById("timer").textContent = "00:00:00";
  document.getElementById("score").textContent = "0";
  document.getElementById("predictedScore").textContent = "0";
  document.getElementById("stabilityBar").style.width = "0%";
  document.getElementById("predictionBar").style.width = "0%";
  document.getElementById("warning").textContent = "";
  drawChart();
  studyStartTime = null;
  studyEndTime = null;
  localStorage.removeItem("liveSession");
}

function startExamMode() {
  document.documentElement.requestFullscreen();
  startTimer();
  document.addEventListener("keydown", function(e){
    if(e.key === "Escape"){
      e.preventDefault();
    }
  });
}

// ================= DISTRACTION DETECTION UPGRADE =================

document.addEventListener("visibilitychange", () => {
  if (document.hidden && active) {
    registerDistraction();
  }
});

window.addEventListener("blur", () => {
  if (active) {
    registerDistraction();
  }
});

function registerDistraction() {
  distractionCount++;

  let stability = Math.max(0, 100 - distractionCount * 5);

  document.getElementById("stabilityBar").style.width = stability + "%";

  focusData.push(stability);
  drawChart();

  document.getElementById("warning").textContent =
    "âš  ì™¸ë¶€ í™œë™ ê°ì§€";
}

function calculateScore() {
  let sleep = parseInt(document.getElementById("sleepInput").value) || 0;
  let runTime = parseInt(document.getElementById("runTimeInput").value) || 0;
  let runDistance = parseFloat(document.getElementById("runDistanceInput").value) || 0;
  let caffeine = parseInt(document.getElementById("caffeineInput").value) || 0;

  currentRunTime = runTime;

  let focusBase = Math.min(100, seconds / 60);
  let distractionPenalty = distractionCount * 5;
  // sleep now in minutes (420 min = 7 hours)
  let sleepBonus = sleep >= 420 ? 10 * adaptiveWeights.sleep : 0;
  let runBonus = (runTime > 20 && runDistance > 2) ? 10 * adaptiveWeights.exercise : 0;
  let caffeinePenalty = caffeine > 2 ? 5 * adaptiveWeights.caffeine : 0;

 // ===== FIXED EXERCISE DAY BONUS (Mon, Tue, Thu, Fri) =====
const today = new Date();
const exerciseDays = [1,2,4,5]; // ì›”í™”ëª©ê¸ˆ
let exerciseDayBonus = exerciseDays.includes(today.getDay()) ? 5 : 0;

let finalScore = Math.max(0,
  focusBase + sleepBonus + runBonus + exerciseDayBonus
  - distractionPenalty - caffeinePenalty
);

  finalScore = Math.min(100, Math.round(finalScore));

  // automatic tuning based on recent 20 sessions
  let sessions = JSON.parse(localStorage.getItem("focusSessions")) || [];
  let recent = sessions.slice(-20);

  if(recent.length > 5){
    let avgSleep = recent.reduce((a,b)=>a+b.sleep,0)/recent.length;
    let avgExercise = recent.reduce((a,b)=>a+b.runTime,0)/recent.length;
    let avgCaffeine = recent.reduce((a,b)=>a+b.caffeine,0)/recent.length;

    let avgScore = recent.reduce((a,b)=>a+b.score,0)/recent.length;

    adaptiveWeights.sleep = 1 + (avgSleep/8) * 0.2;
    adaptiveWeights.exercise = 1 + (avgExercise/60) * 0.2;
    adaptiveWeights.caffeine = 1 + (avgCaffeine/5) * 0.2;
  }

  localStorage.setItem("adaptiveWeights",JSON.stringify(adaptiveWeights));

  // streak-based prediction boost
  let currentStreak = parseInt(document.getElementById("currentStreak").textContent) || 0;
  let streakBoost = Math.min(10, currentStreak * 0.5);
  finalScore = Math.min(100, Math.round(finalScore + streakBoost));

  // AI predicted score (simple model)
  // convert sleep minutes to hours for prediction weight
  let water = parseInt(document.getElementById("waterInput").value) || 0;

  let predicted = Math.round(
  predictScoreAI(sleep, runTime, caffeine, water)
);

  predicted = Math.max(0, Math.min(100, predicted));
  document.getElementById("predictedScore").textContent = predicted;

  // adaptive learning (simple reinforcement)
  if (finalScore > predicted) {
    adaptiveWeights.sleep += 0.01;
    adaptiveWeights.exercise += 0.01;
  }

  document.getElementById("score").textContent = finalScore;
  if (exerciseDayBonus > 0) {
  document.getElementById("warning").textContent =
    "ğŸƒ ìš´ë™ì¼ ë³´ë„ˆìŠ¤ +5 ì ìš©";
}
  // ===== REAL RP CALCULATION =====
let prevRP = rankPoints;

// Decay first
if (finalScore < 50) {
  rankPoints = Math.max(0, rankPoints - 30);
}

// Gain
let rpGain = Math.round(finalScore * 0.5);
if (finalScore === 100) rpGain += 20;
if (finalScore >= 90) rpGain += 10;
if (distractionCount === 0) rpGain += 10;

rankPoints += rpGain;

// Clamp final RP to minimum 0
rankPoints = Math.max(0, rankPoints);

// Real delta
let netGain = rankPoints - prevRP;

// Show RP gain animation (net value)
const rankContainer = document.getElementById("rankContainer");
if (rankContainer && netGain !== 0) {
  const float = document.createElement("div");
  float.className = "rp-float";
  float.textContent = (netGain > 0 ? "+" : "") + netGain + " RP";
  float.style.color = netGain > 0 ? "#34c759" : "#ff3b30";
  rankContainer.appendChild(float);
  setTimeout(()=>float.remove(),1000);
}

localStorage.setItem("rankPoints", rankPoints);

updateRank();
  document.getElementById("predictionBar").style.width = finalScore + "%";

  trainAIModel(finalScore, sleep, runTime, caffeine, water);
  saveSession(finalScore, runTime);
  updateStats();
  updateWeeklyReport();
  drawCorrelation();
  generateHeatmap();
  drawActivityTimeline();
  analyzeFocusRhythm();
  analyzeChronotype();
  saveDashboardState();
// END OF calculateScore()
}

function updateRank() {

  let prevRank = document.getElementById("rankDisplay")?.textContent || "";

  let rank = "Bronze ğŸ¥‰";
  let theme = "rank-bronze";
  let nextThreshold = 500;

  if (rankPoints >= 6000) {
    rank = "Diamond ğŸ’";
    theme = "rank-diamond";
    nextThreshold = 6000;
  }
  else if (rankPoints >= 3000) {
    rank = "Platinum ğŸ†";
    theme = "rank-platinum";
    nextThreshold = 6000;
  }
  else if (rankPoints >= 1500) {
    rank = "Gold ğŸ¥‡";
    theme = "rank-gold";
    nextThreshold = 3000;
  }
  else if (rankPoints >= 500) {
    rank = "Silver ğŸ¥ˆ";
    theme = "rank-silver";
    nextThreshold = 1500;
  }

  document.body.classList.remove(
    "rank-bronze","rank-silver","rank-gold","rank-platinum","rank-diamond"
  );
  document.body.classList.add(theme);

  const rankDisplay = document.getElementById("rankDisplay");
  if (rankDisplay) rankDisplay.textContent = rank;

  if (prevRank && prevRank !== rank && rankDisplay) {
    rankDisplay.classList.add("rank-up");
    setTimeout(()=>rankDisplay.classList.remove("rank-up"),600);
  }

  let base = 0;
  if (rankPoints >= 3000) base = 3000;
  else if (rankPoints >= 1500) base = 1500;
  else if (rankPoints >= 500) base = 500;

  let progress = ((rankPoints - base) / (nextThreshold - base)) * 100;
  progress = Math.max(0, Math.min(100, progress));

  const rpBar = document.getElementById("rpBar");
  const rpText = document.getElementById("rpText");
  const rankProgress = document.getElementById("rankProgress");

  if (rpBar) {
    rpBar.style.transition = "none";
    rpBar.style.width = progress + "%";
    setTimeout(()=>{
      rpBar.style.transition = "width .4s ease";
    },10);
  }
  if (rpText) rpText.textContent = rankPoints + " RP";
  if (rankProgress)
    rankProgress.innerHTML = `ë‹¤ìŒ ë­í¬ê¹Œì§€ ${Math.max(0,nextThreshold-rankPoints)} RP`;
}


function drawChart() {
  ctx.clearRect(0, 0, 300, 120);
  ctx.beginPath();
  ctx.moveTo(0, 120 - (focusData[0] || 0));

  focusData.forEach((value, index) => {
    ctx.lineTo(index * 3, 120 - value);
  });

  ctx.strokeStyle = "#2ea043";
  ctx.stroke();
}

function saveSession(score, runTime) {
  const studyStart = studyStartTime;
  const studyEnd = studyEndTime;
  let sleep = parseInt(document.getElementById("sleepInput").value) || 0;
  let caffeine = parseInt(document.getElementById("caffeineInput").value) || 0;
  let water = parseInt(document.getElementById("waterInput").value) || 0;
  let subject = document.getElementById("subjectInput").value || "ê¸°íƒ€";
  let sessions = JSON.parse(localStorage.getItem("focusSessions")) || [];

  sessions.push({
    score,
    runTime,
    sleep,
    caffeine,
    water,
    subject,
    studyStart,
    studyEnd,
    distractionCount,
    date: Date.now()
  });

  localStorage.setItem("focusSessions", JSON.stringify(sessions));
}

function updateStats() {
  let sessions = JSON.parse(localStorage.getItem("focusSessions")) || [];
  let total = sessions.length;
  let avg = total > 0 ? 
    Math.round(sessions.reduce((a,b)=>a+b.score,0)/total) : 0;

  document.getElementById("totalStats").textContent =
    `ì´ ì„¸ì…˜: ${total} | í‰ê·  ì ìˆ˜: ${avg}`;
}

function updateWeeklyReport() {
  let sessions = JSON.parse(localStorage.getItem("focusSessions")) || [];
  let weekAgo = Date.now() - (7*24*60*60*1000);
  let weekly = sessions.filter(s => s.date > weekAgo);

  let avg = weekly.length > 0 ?
    Math.round(weekly.reduce((a,b)=>a+b.score,0)/weekly.length) : 0;

  document.getElementById("weeklyReport").textContent =
    `ìµœê·¼ 7ì¼ í‰ê·  ì§‘ì¤‘ ì ìˆ˜: ${avg}`;
}

function analyzeFocusRhythm() {
  let sessions = JSON.parse(localStorage.getItem("focusSessions")) || [];

  if (sessions.length < 3) {
    document.getElementById("focusRhythm").textContent =
      "ë°ì´í„°ê°€ ì¶©ë¶„í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.";
    return;
  }

  let hourBuckets = {};
  let totalDuration = 0;
  let validSessions = 0;

  sessions.forEach(s => {
    if (!s.studyStart || !s.studyEnd) return;

    let startHour = new Date(s.studyStart).getHours();
    let duration = (s.studyEnd - s.studyStart) / 60000;

    if (!hourBuckets[startHour]) hourBuckets[startHour] = [];
    hourBuckets[startHour].push(s.score);

    totalDuration += duration;
    validSessions++;
  });

  let peakHour = null;
  let weakHour = null;
  let peakScore = -Infinity;
  let weakScore = Infinity;

  Object.keys(hourBuckets).forEach(hour => {
    let avg = hourBuckets[hour].reduce((a,b)=>a+b,0) / hourBuckets[hour].length;

    if (avg > peakScore) {
      peakScore = avg;
      peakHour = hour;
    }

    if (avg < weakScore) {
      weakScore = avg;
      weakHour = hour;
    }
  });

  let avgDuration = validSessions > 0
    ? Math.round(totalDuration / validSessions)
    : 0;

  document.getElementById("focusRhythm").innerHTML =
    `ğŸ”¥ Peak Hour: ${peakHour}:00 (í‰ê·  ${Math.round(peakScore)}ì )<br>` +
    `âš  Weak Hour: ${weakHour}:00 (í‰ê·  ${Math.round(weakScore)}ì )<br>` +
    `â± í‰ê·  ì§‘ì¤‘ ì§€ì† ì‹œê°„: ${avgDuration}ë¶„`;
}

function analyzeChronotype() {
  let sessions = JSON.parse(localStorage.getItem("focusSessions")) || [];

  if (sessions.length < 5) {
    document.getElementById("chronotypeResult").textContent =
      "ë°ì´í„°ê°€ ì¶©ë¶„í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.";
    return;
  }

  let buckets = { morning: [], afternoon: [], evening: [] };

  sessions.forEach(s => {
    if (!s.studyStart) return;
    let hour = new Date(s.studyStart).getHours();

    if (hour >= 5 && hour < 11) buckets.morning.push(s.score);
    else if (hour >= 11 && hour < 18) buckets.afternoon.push(s.score);
    else buckets.evening.push(s.score);
  });

  function avg(arr) {
    return arr.length
      ? arr.reduce((a,b)=>a+b,0)/arr.length
      : 0;
  }

  let m = avg(buckets.morning);
  let a = avg(buckets.afternoon);
  let e = avg(buckets.evening);

  let type = "ì¤‘ê°„í˜•";

  if (m > a && m > e) type = "ğŸŒ… ì•„ì¹¨í˜• ì§‘ì¤‘ í”„ë¡œíŒŒì¼";
  else if (e > m && e > a) type = "ğŸŒ™ ì €ë…í˜• ì§‘ì¤‘ í”„ë¡œíŒŒì¼";
  else if (m > 70 && e > 70) type = "ğŸ” ì´ì¤‘ í”¼í¬í˜•";

  document.getElementById("chronotypeResult").innerHTML =
    `${type}<br>` +
    `ì˜¤ì „ í‰ê· : ${Math.round(m)}ì <br>` +
    `ì˜¤í›„ í‰ê· : ${Math.round(a)}ì <br>` +
    `ì €ë… í‰ê· : ${Math.round(e)}ì `;
}

function drawCorrelation() {
  let sessions = JSON.parse(localStorage.getItem("focusSessions")) || [];
  corrCtx.clearRect(0,0,300,120);

  if (sessions.length < 2) {
    document.getElementById("correlationValues").textContent =
      "ë°ì´í„°ê°€ ì¶©ë¶„í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.";
    return;
  }

  // sleep stored in minutes (no conversion needed for correlation)
  const scores = sessions.map(s => s.score);
  const sleeps = sessions.map(s => s.sleep);
  const exercises = sessions.map(s => s.runTime);
  const caffeine = sessions.map(s => s.caffeine);

  const rSleep = pearsonCorrelation(sleeps, scores);
  const rExercise = pearsonCorrelation(exercises, scores);
  const rCaffeine = pearsonCorrelation(caffeine, scores);

  sessions.forEach((s)=>{
    corrCtx.fillStyle = "#34c759";
    corrCtx.fillRect(s.runTime*2, 120 - s.score, 4, 4);

    corrCtx.fillStyle = "#0a84ff";
    corrCtx.fillRect(s.sleep*10, 120 - s.score, 3, 3);

    corrCtx.fillStyle = "#ff3b30";
    corrCtx.fillRect(s.caffeine*20, 120 - s.score, 3, 3);
  });

  document.getElementById("correlationValues").innerHTML =
    `ìˆ˜ë©´ r: ${rSleep.toFixed(2)}<br>` +
    `ìš´ë™ r: ${rExercise.toFixed(2)}<br>` +
    `ì¹´í˜ì¸ r: ${rCaffeine.toFixed(2)}`;

  // Call strategy generation based on correlations
  generateDailyStrategy(rSleep, rExercise, rCaffeine);

  // update adaptive weights using real correlation
  adaptiveWeights.sleep = 1 + rSleep;
  adaptiveWeights.exercise = 1 + rExercise;
  adaptiveWeights.caffeine = 1 - rCaffeine;

  localStorage.setItem("adaptiveWeights", JSON.stringify(adaptiveWeights));
}

function drawActivityTimeline() {
  const timeline = document.getElementById("activityTimeline");
  const tctx = timeline.getContext("2d");

  tctx.clearRect(0,0,400,100);

  let sessions = JSON.parse(localStorage.getItem("focusSessions")) || [];
  let today = new Date();

  // ===== FIXED EXERCISE SCHEDULE (15:00â€“16:00, Mon/Tue/Thu/Fri) =====
  const day = today.getDay(); // 0=Sun
  const exerciseDays = [1,2,4,5]; // Mon, Tue, Thu, Fri

  if (exerciseDays.includes(day)) {
    let exStartHour = 15;
    let exEndHour = 16;

    let exX = (exStartHour / 24) * 400;
    let exWidth = ((exEndHour - exStartHour) / 24) * 400;

    tctx.fillStyle = exerciseColor;
    tctx.fillRect(exX, 20, exWidth, 20);
  }

  // background hour grid
  tctx.fillStyle = "#1f2630";
  for(let h=0; h<24; h++){
    let x = (h/24)*400;
    tctx.fillRect(x,0,1,100);
  }

  let todaySessions = sessions
    .filter(s => s.studyStart && new Date(s.studyStart).toDateString() === today.toDateString())
    .sort((a,b)=>a.studyStart - b.studyStart);

  let lastEnd = null;

  todaySessions.forEach(s => {
    let start = new Date(s.studyStart);
    let end = new Date(s.studyEnd);

    let startHour = start.getHours() + start.getMinutes()/60;
    let endHour = end.getHours() + end.getMinutes()/60;

    let x = (startHour / 24) * 400;
    let width = ((endHour - startHour)/24) * 400;

    // draw rest gap
    if(lastEnd){
      let gapStart = lastEnd;
      let gapEnd = start;
      let gapHours = (gapEnd - gapStart)/3600000;
      if(gapHours > 0.2){
        let gapStartHour = gapStart.getHours() + gapStart.getMinutes()/60;
        let gx = (gapStartHour/24)*400;
        let gw = (gapHours/24)*400;
        tctx.fillStyle = "#2d333b";
        tctx.fillRect(gx,40,gw,20);
      }
    }

    // subject color
    let color = subjectColors[s.subject] || subjectColors["ê¸°íƒ€"];

    tctx.fillStyle = color;
    tctx.fillRect(x,30,width,40);

    lastEnd = end;
  });
}

function generateDailyStrategy(rSleep, rExercise, rCaffeine) {
  let strategy = [];

  if (rSleep > 0.3) {
    strategy.push("â€¢ ìˆ˜ë©´ì´ ì§‘ì¤‘ì— í° ì˜í–¥ì„ ì¤ë‹ˆë‹¤. 7ì‹œê°„ ì´ìƒ ìœ ì§€í•˜ì„¸ìš”.");
  }

  if (rExercise > 0.3) {
    strategy.push("â€¢ 20ë¶„ ì´ìƒ ê°€ë²¼ìš´ ìš´ë™ì´ ì§‘ì¤‘ ì ìˆ˜ ìƒìŠ¹ê³¼ ì—°ê²°ë©ë‹ˆë‹¤.");
  }

  if (rCaffeine < -0.3) {
    strategy.push("â€¢ ì¹´í˜ì¸ ì„­ì·¨ê°€ ì ìˆ˜ í•˜ë½ê³¼ ì—°ê²°ë©ë‹ˆë‹¤. ì˜¤ëŠ˜ì€ ì¤„ì—¬ë³´ì„¸ìš”.");
  }

  if (strategy.length === 0) {
    strategy.push("â€¢ í˜„ì¬ ë°ì´í„°ë¡œëŠ” ëª…í™•í•œ íŒ¨í„´ì´ ì—†ìŠµë‹ˆë‹¤. ê¸°ë¡ì„ ë” ìŒ“ì•„ë³´ì„¸ìš”.");
  }

  document.getElementById("dailyStrategy").innerHTML = strategy.join("<br>");
}

function generateHeatmap() {
  const heatmap = document.getElementById("heatmap");
  heatmap.innerHTML = "";

  let sessions = JSON.parse(localStorage.getItem("focusSessions")) || [];

  let year = heatmapDate.getFullYear();
  let month = heatmapDate.getMonth();

  document.getElementById("heatmapMonth").textContent =
    `${year} / ${month + 1}`;

  let daysInMonth = new Date(year, month + 1, 0).getDate();

  for (let d = 1; d <= daysInMonth; d++) {
    let cell = document.createElement("div");

    let daySessions = sessions.filter(s => {
      let date = new Date(s.date);
      return date.getFullYear() === year &&
             date.getMonth() === month &&
             date.getDate() === d;
    });

    if (daySessions.length > 0) {
      let avg = Math.round(daySessions.reduce((a,b)=>a+b.score,0)/daySessions.length);
      let intensity = avg / 100;
      cell.style.background = `rgba(52,199,89,${intensity})`;
    }

    heatmap.appendChild(cell);
  }

  calculateStreak();
}

function changeMonth(offset) {
  heatmapDate.setMonth(heatmapDate.getMonth() + offset);
  generateHeatmap();
}

function calculateStreak() {
  let sessions = JSON.parse(localStorage.getItem("focusSessions")) || [];

  let dates = sessions
    .map(s => {
      let d = new Date(s.date);
      return new Date(d.getFullYear(), d.getMonth(), d.getDate()).getTime();
    });

  let uniqueDates = [...new Set(dates)].sort((a,b)=>a-b);

  let currentStreak = 0;
  let bestStreak = 0;

  let today = new Date();
  let todayKey = new Date(today.getFullYear(), today.getMonth(), today.getDate()).getTime();

  let streak = 0;

  for (let i = 0; i < uniqueDates.length; i++) {
    if (i === 0) {
      streak = 1;
    } else {
      if (uniqueDates[i] - uniqueDates[i-1] === 86400000) {
        streak++;
      } else {
        bestStreak = Math.max(bestStreak, streak);
        streak = 1;
      }
    }
  }

  bestStreak = Math.max(bestStreak, streak);

  // current streak (count backwards from today)
  let checkDate = todayKey;
  while (uniqueDates.includes(checkDate)) {
    currentStreak++;
    checkDate -= 86400000;
  }

  document.getElementById("currentStreak").textContent = currentStreak;
  document.getElementById("bestStreak").textContent = bestStreak;

  updateStamps(currentStreak, bestStreak);

  let badge = document.getElementById("streakBadge");
  badge.innerHTML = "";

  if (currentStreak >= 30) {
    badge.innerHTML = '<div class="badge">ğŸ”¥ 30 Day Streak Master</div>';
    for (let i=0;i<50;i++){
      let piece = document.createElement("div");
      piece.className = "confetti-piece";
      piece.style.left = Math.random()*100 + "vw";
      piece.style.background = ["#34c759","#0a84ff","#ff3b30"][Math.floor(Math.random()*3)];
      document.body.appendChild(piece);
      setTimeout(()=>piece.remove(),2000);
    }
  } else if (currentStreak >= 7) {
    badge.innerHTML = '<div class="badge">âš¡ 7 Day Consistency</div>';
  }

  // streak break warning
  if (currentStreak > 0) {
    let today = new Date();
    let hoursLeft = 24 - today.getHours();
    if (hoursLeft <= 2) {
      document.getElementById("warning").textContent = "âš  Streak ëŠê¸°ê¸°ê¹Œì§€ ì–¼ë§ˆ ì•ˆ ë‚¨ìŒ";
    }
  }
}

function updateStamps(currentStreak, bestStreak) {
  let sessions = JSON.parse(localStorage.getItem("focusSessions")) || [];
  let totalSessions = sessions.length;

  const stampGrid = document.getElementById("stampGrid");
  stampGrid.innerHTML = "";

  // ========== RARITY & PERFECT 100 SYSTEM ==========
  const achievements = [
    { label:"ğŸ¯", title:"ì²« ì„¸ì…˜ ê¸°ë¡", rarity:"common", condition: totalSessions >= 1 },
    { label:"ğŸ“˜", title:"10 ì„¸ì…˜ ë‹¬ì„±", rarity:"common", condition: totalSessions >= 10 },
    { label:"ğŸ“š", title:"30 ì„¸ì…˜ ë‹¬ì„±", rarity:"rare", condition: totalSessions >= 30 },
    { label:"ğŸ§ ", title:"50 ì„¸ì…˜ ë‹¬ì„±", rarity:"rare", condition: totalSessions >= 50 },
    { label:"ğŸ’", title:"100 ì„¸ì…˜ ë‹¬ì„±", rarity:"legendary", condition: totalSessions >= 100 },

    { label:"ğŸ”¥", title:"7ì¼ ì—°ì†", rarity:"common", condition: currentStreak >= 7 },
    { label:"âš¡", title:"14ì¼ ì—°ì†", rarity:"rare", condition: currentStreak >= 14 },
    { label:"ğŸ†", title:"30ì¼ ì—°ì†", rarity:"legendary", condition: bestStreak >= 30 },
    { label:"ğŸ‘‘", title:"60ì¼ ì—°ì†", rarity:"legendary", condition: bestStreak >= 60 },

    { label:"ğŸŒ…", title:"ì•„ì¹¨í˜• ì§‘ì¤‘ ë‹¬ì„±", rarity:"rare", condition: document.getElementById("chronotypeResult").textContent.includes("ì•„ì¹¨í˜•") },
    { label:"ğŸŒ™", title:"ì €ë…í˜• ì§‘ì¤‘ ë‹¬ì„±", rarity:"rare", condition: document.getElementById("chronotypeResult").textContent.includes("ì €ë…í˜•") },

    { label:"âš–ï¸", title:"í‰ê·  ì ìˆ˜ 80 ì´ìƒ", rarity:"rare", condition: totalSessions > 5 && (sessions.reduce((a,b)=>a+b.score,0)/totalSessions) >= 80 },

    { label:"ğŸƒ", title:"ìš´ë™ ì„¸ì…˜ 20íšŒ", rarity:"common", condition: sessions.filter(s=>s.runTime>0).length >= 20 },

    { label:"ğŸ“ˆ", title:"ìµœê·¼ 7ì„¸ì…˜ í‰ê·  85 ì´ìƒ", rarity:"rare",
      condition: sessions.slice(-7).length === 7 &&
        (sessions.slice(-7).reduce((a,b)=>a+b.score,0)/7) >= 85
    },

    { label:"ğŸ’¯", title:"Perfect 100 ì  ë‹¬ì„±", rarity:"legendary",
      condition: sessions.some(s => s.score === 100)
    }
    // NEW LEGENDARY BADGE
    ,{
      label:"ğŸŒŒ",
      title:"Ultimate Focus Master (í‰ê·  90 + 50ì„¸ì…˜ ì´ìƒ)",
      rarity:"legendary",
      condition: totalSessions >= 50 &&
                 (sessions.reduce((a,b)=>a+b.score,0)/totalSessions) >= 90
    }
  ];

  achievements.forEach(a => {
    const wrapper = document.createElement("div");
    wrapper.className = "stamp-wrapper";

    const div = document.createElement("div");
    div.className = "stamp " + a.rarity;
    div.textContent = a.label;

    if (a.condition) {
      div.classList.add("unlocked");
      div.classList.add("pop");
    }

    const tooltip = document.createElement("div");
    tooltip.className = "stamp-tooltip";
    tooltip.textContent = a.title;

    wrapper.appendChild(div);
    wrapper.appendChild(tooltip);
    stampGrid.appendChild(wrapper);
  });
}

updateStats();
updateWeeklyReport();
drawCorrelation();
generateHeatmap();
drawActivityTimeline();
analyzeFocusRhythm();
analyzeChronotype();
updateStamps(0,0);
updateRank();
loadLiveSessionState();
loadBodyInputs();
loadDashboardState();
</script>

</body>
</html>
