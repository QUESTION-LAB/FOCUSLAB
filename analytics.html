<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>FOCUSLAB AI Analytics</title>

<style>
body {
  margin:0;
  font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto;
  background:#0d1117;
  color:#e6edf3;
}

header {
  padding:24px;
  font-size:22px;
  font-weight:600;
  border-bottom:1px solid #222;
}

.container {
  padding:24px;
  display:grid;
  grid-template-columns:1fr 1fr;
  gap:24px;
}

.card {
  background:#161b22;
  border:1px solid #2d333b;
  border-radius:16px;
  padding:20px;
}

.card h3 {
  margin-top:0;
  font-size:16px;
  opacity:.8;
}

canvas {
  width:100%;
  height:220px;
}

.metric {
  font-size:36px;
  font-weight:600;
}

.sub {
  opacity:.6;
  font-size:13px;
}

.weight-row {
  margin-bottom:10px;
}

.bar {
  height:6px;
  background:#30363d;
  border-radius:6px;
  overflow:hidden;
}

.bar-inner {
  height:100%;
  background:#3b82f6;
}

/* --- AI Activation Animation --- */
@keyframes aiActivate {
  0% { transform: scale(0.95); opacity:0; }
  50% { transform: scale(1.05); opacity:1; }
  100% { transform: scale(1); }
}
.ai-activated {
  animation: aiActivate 0.8s ease-out;
  box-shadow: 0 0 25px rgba(16,185,129,0.6);
  border:1px solid #10b981 !important;
}

header {
  /* subtle pulse effect */
  animation: headerPulse 2.4s infinite alternate cubic-bezier(0.4,0,0.2,1);
}
@keyframes headerPulse {
  0% { box-shadow: 0 0 0 0 rgba(16,185,129,0.08);}
  100% { box-shadow: 0 0 12px 0 rgba(16,185,129,0.18);}
}

/* Premium Minimal AI Notice Card */
.ai-notice {
  background: linear-gradient(135deg,#111827,#0f172a);
  border: 1px solid #1f2937;
  position: relative;
  overflow: hidden;
}

.ai-notice::after {
  content:"";
  position:absolute;
  top:0;
  left:0;
  width:100%;
  height:2px;
  background:linear-gradient(90deg,#10b981,#3b82f6);
  opacity:0.7;
}

.ai-notice-header {
  display:flex;
  align-items:center;
  gap:10px;
  margin-bottom:10px;
}

.ai-dot {
  width:10px;
  height:10px;
  border-radius:50%;
  background:#f59e0b;
  box-shadow:0 0 10px rgba(245,158,11,0.6);
}
.ai-dot.active {
  background:#10b981;
  box-shadow:0 0 12px rgba(16,185,129,0.8);
  animation: aiPulse 1.2s infinite alternate;
}
@keyframes aiPulse {
  0% { transform: scale(1); }
  100% { transform: scale(1.2); }
}

.ai-title {
  font-size:14px;
  font-weight:600;
  letter-spacing:0.5px;
  opacity:0.9;
}

.ai-notice-body {
  font-size:14px;
  opacity:0.7;
  line-height:1.5;
}
</style>
</head>
<body>

<header style="display:flex; justify-content:space-between; align-items:center;">
  <div>AI ëª¨ë¸ ë¶„ì„ ëŒ€ì‹œë³´ë“œ</div>
  <button onclick="goToIndex()" style="
    background:#21262d;
    color:#e6edf3;
    border:1px solid #30363d;
    padding:8px 14px;
    border-radius:8px;
    cursor:pointer;
  ">â† ëŒ€ì‹œë³´ë“œ</button>
</header>

<div class="container">

  <!-- AI Data Notice Card -->
  <div id="dataNoticeCard" class="card ai-notice" style="grid-column:1 / span 2; display:none;">
    <div class="ai-notice-header">
      <div class="ai-dot"></div>
      <div class="ai-title">AI Learning Standby</div>
    </div>
    <div class="ai-notice-body" id="dataNoticeText"></div>
  </div>

  <div class="card">
    <h3>ğŸ“‰ í‰ê·  ì˜¤ì°¨ìœ¨ (MAE)</h3>
    <div class="metric" id="maeValue">0</div>
    <div class="sub">Actual vs Predicted í‰ê·  ì ˆëŒ€ ì˜¤ì°¨</div>
  </div>

  <div class="card">
    <h3>ğŸ¯ ëª¨ë¸ ì •í™•ë„ (RÂ²)</h3>
    <div class="metric" id="accuracyValue">0%</div>
    <div class="sub">ê²°ì •ê³„ìˆ˜ ê¸°ë°˜ ì„¤ëª…ë ¥</div>
  </div>

  <div class="card">
    <h3>âš  ì˜ˆì¸¡ ì˜¤ì°¨ìœ¨</h3>
    <div class="metric" id="errorRateValue">0%</div>
    <div class="sub">MAE / 100 ì •ê·œí™” ë¹„ìœ¨</div>
  </div>

  <div class="card">
    <h3>ğŸ§  ëª¨ë¸ ì‹ ë¢°ë„</h3>
    <div class="metric" id="confidenceValue">0%</div>
    <div class="sub">ë°ì´í„° ì¶•ì  ê¸°ë°˜ ì‹ ë¢°ë„</div>
  </div>

  <div class="card">
    <h3>ğŸ“¦ ì„¸ì…˜ ìˆ˜</h3>
    <div class="metric" id="sessionCountValue">0</div>
    <div class="sub">í˜„ì¬ í•™ìŠµì— ì‚¬ìš©ëœ ì„¸ì…˜ ìˆ˜</div>
  </div>

  <div class="card">
    <h3>ğŸ“Š ì˜¤ì°¨ ì¶”ì´ ê·¸ë˜í”„</h3>
    <canvas id="errorChart"></canvas>
  </div>

  <div class="card">
    <h3>ğŸ§  ê°€ì¤‘ì¹˜ ì‹œê°í™”</h3>
    <div id="weightsContainer"></div>
  </div>

  <div class="card" style="grid-column:1 / span 2;">
    <h3>ğŸ“ˆ Learning Curve (Loss vs Epoch)</h3>
    <canvas id="lossChart"></canvas>
  </div>

  <div class="card" style="grid-column:1 / span 2;">
    <h3>ğŸ“Š Actual vs Predicted (Scatter Plot)</h3>
    <canvas id="scatterChart"></canvas>
  </div>

  <div class="card" style="grid-column:1 / span 2;">
    <h3>ğŸ”„ Online Learning Progress (Session Error Trend)</h3>
    <canvas id="onlineChart"></canvas>
  </div>

</div>

<script>

function goToIndex(){ window.location.href="index.html"; }

const sessions = JSON.parse(localStorage.getItem("focusSessions")) || [];
const MIN_SESSIONS = 10;

const noticeCard = document.getElementById("dataNoticeCard");
const noticeDot = document.querySelector(".ai-dot");
const noticeTitle = document.querySelector(".ai-title");
const noticeText = document.getElementById("dataNoticeText");

// ===== Model Confidence =====
const modelConfidence = Math.min(100, sessions.length * 3);

const cacheKey = "analyticsCache";
const cached = JSON.parse(localStorage.getItem(cacheKey) || "null");
let useCache = false;

if (cached && cached.sessionCount === sessions.length) {
  useCache = true;
}

// ================= DATA =================
const X = sessions.map(s=>[
  s.sleep||0,
  s.runTime||0,
  s.caffeine||0,
  s.water||0
]);
const y = sessions.map(s=>s.score||0);

const splitIdx=Math.floor(X.length*0.8);
const X_train=X.slice(0,splitIdx);
const y_train=y.slice(0,splitIdx);
const X_val=X.slice(splitIdx);
const y_val=y.slice(splitIdx);

// ================= NORMALIZATION =================
function normalize(X){
  const means=[],stds=[];
  for(let j=0;j<X[0].length;j++){
    const col=X.map(r=>r[j]);
    const mean=col.reduce((a,b)=>a+b,0)/col.length;
    const std=Math.sqrt(col.reduce((a,b)=>a+Math.pow(b-mean,2),0)/col.length)||1;
    means.push(mean); stds.push(std);
  }
  return {
    Xn:X.map(r=>r.map((v,j)=>(v-means[j])/stds[j])),
    means,stds
  };
}



// ================= NEURAL NETWORK =================

const inputSize = 4;
const hiddenSize = 8;

// Initialize weights
let W1 = Array.from({length:inputSize},()=>
  Array.from({length:hiddenSize},()=>Math.random()*0.1-0.05)
);
let b1 = new Array(hiddenSize).fill(0);

let W2 = Array.from({length:hiddenSize},()=>Math.random()*0.1-0.05);
let b2 = 0;

function relu(x){ return Math.max(0,x); }
function reluDeriv(x){ return x>0?1:0; }

function forward(x){
  const z1 = new Array(hiddenSize).fill(0);
  const a1 = new Array(hiddenSize).fill(0);

  for(let j=0;j<hiddenSize;j++){
    for(let i=0;i<inputSize;i++){
      z1[j]+=x[i]*W1[i][j];
    }
    z1[j]+=b1[j];
    a1[j]=relu(z1[j]);
  }

  let z2=0;
  for(let j=0;j<hiddenSize;j++){
    z2+=a1[j]*W2[j];
  }
  z2+=b2;

  return {z1,a1,z2};
}

// ================= TRAIN (ADAM OPTIMIZER) =================
let lossHistory=[];

function train(epochs=1200, lr=0.005){

  const beta1 = 0.9;
  const beta2 = 0.999;
  const epsilon = 1e-8;

  // Adam state
  let mW1 = W1.map(row=>row.map(()=>0));
  let vW1 = W1.map(row=>row.map(()=>0));
  let mb1 = new Array(hiddenSize).fill(0);
  let vb1 = new Array(hiddenSize).fill(0);

  let mW2 = new Array(hiddenSize).fill(0);
  let vW2 = new Array(hiddenSize).fill(0);
  let mb2 = 0;
  let vb2 = 0;

  let t = 0;

  for(let e=0;e<epochs;e++){
    let totalLoss=0;

    for(let n=0;n<X_train_n.length;n++){
      t++;

      const {z1,a1,z2}=forward(X_train_n[n]);
      const yHat=z2;
      const error=yHat-y_train[n];
      totalLoss+=error*error;

      // Output gradients
      const dW2 = a1.map(a=>a*error);
      const db2 = error;

      // Hidden gradients
      const dHidden = new Array(hiddenSize);
      for(let j=0;j<hiddenSize;j++){
        dHidden[j]=W2[j]*error*reluDeriv(z1[j]);
      }

      // === ADAM UPDATE W2 ===
      for(let j=0;j<hiddenSize;j++){
        mW2[j]=beta1*mW2[j]+(1-beta1)*dW2[j];
        vW2[j]=beta2*vW2[j]+(1-beta2)*(dW2[j]**2);

        const mHat=mW2[j]/(1-Math.pow(beta1,t));
        const vHat=vW2[j]/(1-Math.pow(beta2,t));

        W2[j]-=lr*mHat/(Math.sqrt(vHat)+epsilon);
      }

      mb2=beta1*mb2+(1-beta1)*db2;
      vb2=beta2*vb2+(1-beta2)*(db2**2);
      const mb2Hat=mb2/(1-Math.pow(beta1,t));
      const vb2Hat=vb2/(1-Math.pow(beta2,t));
      b2-=lr*mb2Hat/(Math.sqrt(vb2Hat)+epsilon);

      // === ADAM UPDATE W1 ===
      for(let i=0;i<inputSize;i++){
        for(let j=0;j<hiddenSize;j++){
          const grad = X_train_n[n][i]*dHidden[j];

          mW1[i][j]=beta1*mW1[i][j]+(1-beta1)*grad;
          vW1[i][j]=beta2*vW1[i][j]+(1-beta2)*(grad**2);

          const mHat=mW1[i][j]/(1-Math.pow(beta1,t));
          const vHat=vW1[i][j]/(1-Math.pow(beta2,t));

          W1[i][j]-=lr*mHat/(Math.sqrt(vHat)+epsilon);
        }
      }

      for(let j=0;j<hiddenSize;j++){
        mb1[j]=beta1*mb1[j]+(1-beta1)*dHidden[j];
        vb1[j]=beta2*vb1[j]+(1-beta2)*(dHidden[j]**2);

        const mHat=mb1[j]/(1-Math.pow(beta1,t));
        const vHat=vb1[j]/(1-Math.pow(beta2,t));

        b1[j]-=lr*mHat/(Math.sqrt(vHat)+epsilon);
      }
    }

    lossHistory.push(totalLoss/X_train_n.length);
  }
}

let valPred, valMAE, valR2;

if (sessions.length < MIN_SESSIONS) {

  noticeCard.style.display = "block";
  noticeText.innerHTML =
    `í˜„ì¬ ì„¸ì…˜ ìˆ˜: <b>${sessions.length}</b>ê°œ<br>
     ìµœì†Œ ${MIN_SESSIONS}ê°œ ì´ìƒë¶€í„° AI í•™ìŠµì´ ì‹œì‘ë©ë‹ˆë‹¤.`;

  valPred = [];
  valMAE = 0;
  valR2 = 0;
  lossHistory = [];

} else {

  noticeCard.style.display = "block";
  noticeDot.classList.add("active");
  noticeTitle.textContent = "AI Training Active";
  noticeText.innerHTML =
    `í˜„ì¬ ì„¸ì…˜ ìˆ˜: <b>${sessions.length}</b>ê°œ<br>
     ì¸ê³µì§€ëŠ¥ì´ ë°ì´í„°ë¥¼ í•™ìŠµ ì¤‘ì…ë‹ˆë‹¤...`;

  // noticeCard.style.display = "none";

  // ğŸ”¥ Advanced AI Activation when reaching 30 sessions
  if (sessions.length === 30) {
    const headerEl = document.querySelector("header");
    headerEl.classList.add("ai-activated");

    // Change header title temporarily
    const titleEl = headerEl.querySelector("div");
    const originalText = titleEl.textContent;
    titleEl.textContent = "ğŸ§  Advanced AI Mode Activated";

    setTimeout(()=>{
      headerEl.classList.remove("ai-activated");
      titleEl.textContent = originalText;
    },1800);
  }

  const {Xn:X_train_n,means,stds}=normalize(X_train);
  const X_val_n=X_val.map(r=>r.map((v,j)=>(v-means[j])/stds[j]));

  if (!useCache) {
    train();
    valPred = predictBatch(X_val_n);
    valMAE = MAE(y_val,valPred);
    valR2 = R2(y_val,valPred);

    localStorage.setItem(cacheKey, JSON.stringify({
      sessionCount: sessions.length,
      lossHistory,
      valPred,
      valMAE,
      valR2
    }));
  } else {
    lossHistory = cached.lossHistory;
    valPred = cached.valPred;
    valMAE = cached.valMAE;
    valR2 = cached.valR2;
  }
}

// ================= METRICS =================

// ================= UI =================
document.getElementById("maeValue").textContent = valMAE.toFixed(2);
document.getElementById("accuracyValue").textContent = (valR2*100).toFixed(1)+"%";

const errorRate = Math.min(100, (valMAE/100)*100);
document.getElementById("errorRateValue").textContent = errorRate.toFixed(1)+"%";

document.getElementById("confidenceValue").textContent = modelConfidence + "%";
document.getElementById("sessionCountValue").textContent = sessions.length;


// ================= LOSS GRAPH =================
function drawLoss(){
  const c=document.getElementById("lossChart");
  const ctx=c.getContext("2d");
  ctx.clearRect(0,0,c.width,c.height);
  ctx.beginPath(); ctx.strokeStyle="#10b981";

  const maxLoss=Math.max(...lossHistory);
  lossHistory.forEach((l,i)=>{
    const x=(i/(lossHistory.length-1))*c.width;
    const yPos=c.height-(l/maxLoss)*c.height;
    if(i===0)ctx.moveTo(x,yPos);
    else ctx.lineTo(x,yPos);
  });
  ctx.stroke();
}
drawLoss();

// ================= ERROR GRAPH =================
function drawErrorChart(){
  const c=document.getElementById("errorChart");
  const ctx=c.getContext("2d");
  ctx.clearRect(0,0,c.width,c.height);
  ctx.beginPath(); ctx.strokeStyle="#3b82f6";

  valPred.forEach((p,i)=>{
    const err=Math.abs(p-y_val[i]);
    const x=(i/(valPred.length-1))*c.width;
    const yPos=c.height-(err/100)*c.height;
    if(i===0)ctx.moveTo(x,yPos);
    else ctx.lineTo(x,yPos);
  });
  ctx.stroke();
}
drawErrorChart();

// ================= SCATTER PLOT =================
function drawScatter(){
  const c=document.getElementById("scatterChart");
  const ctx=c.getContext("2d");
  ctx.clearRect(0,0,c.width,c.height);

  const padding=30;
  const width=c.width-padding*2;
  const height=c.height-padding*2;

  // draw diagonal reference line
  ctx.beginPath();
  ctx.strokeStyle="#444";
  ctx.moveTo(padding,padding+height);
  ctx.lineTo(padding+width,padding);
  ctx.stroke();

  // plot points
  ctx.fillStyle="#3b82f6";

  valPred.forEach((pred,i)=>{
    const actual=y_val[i];

    const x=padding+(actual/100)*width;
    const y=padding+height-(pred/100)*height;

    ctx.beginPath();
    ctx.arc(x,y,4,0,Math.PI*2);
    ctx.fill();
  });
}

drawScatter();

// ================= ONLINE LEARNING GRAPH =================
function drawOnlineLearning(){
  if(!sessions.length) return;

  const c=document.getElementById("onlineChart");
  const ctx=c.getContext("2d");
  ctx.clearRect(0,0,c.width,c.height);

  // normalize full dataset using training means/stds
  const X_all = sessions.map(s=>[
    s.sleep||0,
    s.runTime||0,
    s.caffeine||0,
    s.water||0
  ]);

  const X_all_n = X_all.map(r=>r.map((v,j)=>(v-means[j])/stds[j]));

  const preds = X_all_n.map(x=>forward(x).z2);

  const errors = preds.map((p,i)=>Math.abs(p-(sessions[i].score||0)));

  ctx.beginPath();
  ctx.strokeStyle="#f59e0b";

  const maxErr = Math.max(...errors,1);

  errors.forEach((err,i)=>{
    const x=(i/(errors.length-1))*c.width;
    const y=c.height-(err/maxErr)*c.height;
    if(i===0) ctx.moveTo(x,y);
    else ctx.lineTo(x,y);
  });

  ctx.stroke();
}

drawOnlineLearning();

// ================= WEIGHT VISUAL =================
const container=document.getElementById("weightsContainer");
container.innerHTML="ğŸ§  Hidden Layer: "+hiddenSize+" nodes";

</script>

</body>
</html>
